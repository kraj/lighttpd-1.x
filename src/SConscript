import os
import re
import types

Import('env')

common_src = Split("buffer.c log.c \
      keyvalue.c chunk.c  \
      stream.c fdevent.c \
      stat_cache.c plugin.c joblist.c etag.c array.c \
      data_string.c data_count.c data_array.c \
      data_integer.c md5.c data_fastcgi.c \
      fdevent_select.c fdevent_linux_rtsig.c \
      fdevent_poll.c fdevent_linux_sysepoll.c \
      fdevent_solaris_devpoll.c fdevent_freebsd_kqueue.c \
      data_config.c bitset.c \
      inet_ntop_cache.c crc32.c \
      connections-glue.c iosocket.c \
      configfile-glue.c \
      http-header-glue.c status_counter.c \
      splaytree.c network_writev.c \
      network_write.c network_linux_sendfile.c \
      network_freebsd_sendfile.c  network_win32_send.c \
      network_solaris_sendfilev.c network_openssl.c \
      http_resp.c http_resp_parser.c \
      http_req.c http_req_parser.c \
      http_req_range.c http_req_range_parser.c ")

      
src = Split("server.c response.c connections.c network.c sys-socket.c sys-files.c\
      configfile.c configparser.c request.c proc_open.c")

if re.compile("win32").search(env['PLATFORM']):
	src += [ 'getopt.c' ]

lemon = env.Program('lemon', 'lemon.c')
def lemonemitter(target, source, env):
	import os, SCons
	path = SCons.Util.to_String(target[0])
	base, ext = os.path.splitext(path)
	target += [ base + '.h' ]

	# the hard way to workaround scons bug
	if os.path.exists(path) != os.path.exists(base + '.h'):
		if os.path.exists(path):
			os.remove(path)
		else:
			os.remove(base + '.h')

	env.Depends(target, lemon)
	return (target, source)

if re.compile("win32").search(env['PLATFORM']):
	lemoncmd = '..\\' + lemon[0].path + ' -q ..\\$SOURCE ..\\src\\lempar.c || (del ..\\${TARGETS[0]} ..\\${TARGETS[1]} && exit 1)'
else:
	lemoncmd = '../' + lemon[0].path + ' -q ../$SOURCE ../src/lempar.c || (rm ../${TARGETS[0]} ../${TARGETS[1]} && exit 1)'
lemonbuilder = Builder(action=lemoncmd, chdir=1, emitter=lemonemitter, suffix='c')
env.Append(BUILDERS = {'Lemon': lemonbuilder})

configparser = env.Lemon('configparser.y');
mod_ssi_exprparser = env.Lemon('mod_ssi_exprparser.y');
http_resp_parser = env.Lemon('http_resp_parser.y');
http_req_parser = env.Lemon('http_req_parser.y');
http_req_range_parser = env.Lemon('http_req_range_parser.y');

testenv = env.Copy(LIBS = ['-ltap', '-lpcre'])

resptest = testenv.Program('http_resp.t', 
    [ 'http_resp_parser.c', 'http_resp.c', 'buffer.c', 'array.c', 'chunk.c',
      'keyvalue.c', 'data_string.c', 'http_resp_test.c', 'log.c'
    ] )

reqtest = testenv.Program('http_req.t', 
    [ 'http_req_parser.c', 'http_req.c', 'buffer.c', 'array.c', 'chunk.c',
      'keyvalue.c', 'data_string.c', 'http_req_test.c', 'log.c'
    ] )

reqrangetest = testenv.Program('http_req_range.t', 
    [ 'http_req_range_parser.c', 'http_req_range.c', 'buffer.c', 'array.c', 'chunk.c',
      'keyvalue.c', 'data_string.c', 'http_req_range_test.c', 'log.c'
    ] )

testenv.Alias('bin-tests', [resptest, reqtest, reqrangetest ] )

## the modules and how they are built
modules = {
	'mod_access' : { 'src' : [ 'mod_access.c' ] },
	'mod_alias' : { 'src' : [ 'mod_alias.c' ] },
	'mod_cgi' : { 'src' : [ 'mod_cgi.c' ] },
	'mod_fastcgi' : { 'src' : [ 'mod_fastcgi.c' ] },
	'mod_scgi' : { 'src' : [ 'mod_scgi.c' ] },
	'mod_dirlisting' : { 'src' : [ 'mod_dirlisting.c' ], 'lib' : [ env['LIBPCRE'] ] },
	'mod_staticfile' : { 'src' : [ 'mod_staticfile.c' ] },

	'mod_indexfile' : { 'src' : [ 'mod_indexfile.c' ] },
	'mod_setenv' : { 'src' : [ 'mod_setenv.c' ] },
	'mod_rrdtool' : { 'src' : [ 'mod_rrdtool.c' ] },
	'mod_usertrack' : { 'src' : [ 'mod_usertrack.c' ] },
	'mod_proxy' : { 'src' : [ 'mod_proxy.c' ] },
	'mod_proxy_core' : { 'src' : [ 
		'mod_proxy_core.c', 
		'mod_proxy_core_pool.c', 
		'mod_proxy_core_backend.c', 
		'mod_proxy_core_address.c', 
		'mod_proxy_core_backlog.c', 
		'mod_proxy_core_rewrites.c', 
		'mod_proxy_backend_http.c',
		'mod_proxy_backend_fastcgi.c'
	 ] },
	'mod_userdir' : { 'src' : [ 'mod_userdir.c' ] },
	'mod_secdownload' : { 'src' : [ 'mod_secure_download.c' ] },
	'mod_accesslog' : { 'src' : [ 'mod_accesslog.c' ] },
	'mod_simple_vhost' : { 'src' : [ 'mod_simple_vhost.c' ] },
	'mod_evhost' : { 'src' : [ 'mod_evhost.c' ] },
	'mod_expire' : { 'src' : [ 'mod_expire.c' ] },
	'mod_status' : { 'src' : [ 'mod_status.c' ] },
	'mod_compress' : { 'src' : [ 'mod_compress.c' ], 'lib' : [ env['LIBZ'], env['LIBBZ2'] ] },
	'mod_redirect' : { 'src' : [ 'mod_redirect.c' ], 'lib' : [ env['LIBPCRE'] ] },
	'mod_rewrite' : { 'src' : [ 'mod_rewrite.c' ], 'lib' : [ env['LIBPCRE'] ] },
	'mod_auth' : { 
		'src' : [ 'mod_auth.c', 'http_auth_digest.c', 'http_auth.c' ], 
		'lib' : [ env['LIBCRYPT'], env['LIBLDAP'], env['LIBLBER'] ] },
	'mod_webdav' : { 'src' : [ 'mod_webdav.c' ], 'lib' : [ env['LIBXML2'], env['LIBSQLITE3'] ] },
	'mod_sql_vhost_core' : { 'src' : [ 'mod_sql_vhost_core.c' ] },
	'mod_mysql_vhost' : { 'src' : [ 'mod_mysql_vhost.c' ], 'lib' : [ env['LIBMYSQL'] ] },
	'mod_trigger_b4_dl' : { 'src' : [ 'mod_trigger_b4_dl.c' ], 'lib' : [ env['LIBPCRE'] ] },
	'mod_cml' : { 
		'src' : [ 'mod_cml_lua.c', 'mod_cml.c', 'mod_cml_funcs.c' ], 
		'lib' : [ env['LIBPCRE'], env['LIBMEMCACHE'], env['LIBLUA'], env['LIBLUALIB'] ] },
	'mod_uploadprogress' : { 'src' : [ 'mod_uploadprogress.c' ] },
	'mod_evasive' : { 'src' : [ 'mod_evasive.c' ] },
	'mod_ssi' : { 'src' : [ 'mod_ssi_exprparser.c', 'mod_ssi_expr.c', 'mod_ssi.c' ], 'lib' : [ env['LIBPCRE'] ] },
	'mod_flv_streaming' : { 'src' : [ 'mod_flv_streaming.c' ] },
}

staticenv = env.Copy(CPPFLAGS=[ env['CPPFLAGS'], '-DLIGHTTPD_STATIC', '-DOPENSSL_NO_KRB5'])

## all the core-sources + the modules
staticsrc = src + common_src

staticlib = env['LIBS'] 
staticinit = ''
for module in modules.keys():
	staticsrc += modules[module]['src']
	staticinit += "PLUGIN_INIT(%s)\n"%module
	if modules[module].has_key('lib'):
		staticlib += modules[module]['lib']

#file('plugin-static.h', 'wb+').write(staticinit)

## turn all src-files into objects
staticobj = []
for cfile in staticsrc:
	staticobj += [ staticenv.Object('static-' + cfile.replace('.c', ''), cfile) ]

staticbin = staticenv.Program('lighttpd-semi-static', 
	staticobj, 
	LIBS = staticlib
	)

## you might have to adjust the list of libs and the order for your setup
## this is tricky, be warned
fullstaticlib = []

## try to calculate the libs for fullstatic with ldd
## 1. find the lib
## 2. check the deps
## 3. add them to the libs
searchlibs = os.pathsep.join([ '/lib/', '/usr/lib/', '/usr/local/lib/' ])
lddre = re.compile(r'^\s+lib([^=-]+)(?:-[\.0-9]+)?\.so\.[0-9]+ =>', re.MULTILINE)
for libs in staticlib:
	if type(libs) is types.StringType: libs = [ libs ]
	for lib in libs:
		fullstaticlib += [ lib ]
		solibpath = env.WhereIs('lib' + lib + '.so', searchlibs)
		fullstaticlib += [ lib ]
		if solibpath is None:
			continue

		f = os.popen('ldd ' + solibpath, 'r')
		for aword in lddre.findall(f.read()):
			fullstaticlib += [ aword ]
		f.close


fullstaticbin = staticenv.Program('lighttpd-static', 
	staticobj, 
	LIBS = fullstaticlib, 
	LINKFLAGS= ['-static'] 
	)

Alias('static', staticbin)
Alias('fullstatic', fullstaticbin)

implib = 'lighttpd.exe.a'
bin_targets = ['lighttpd']
bin_linkflags = [ env['LINKFLAGS'] ]
if env['COMMON_LIB'] == 'lib':
	common_lib = env.SharedLibrary('liblighttpd', common_src, LINKFLAGS = [ env['LINKFLAGS'], '-Wl,--export-dynamic' ])
else:
	src += common_src
	common_lib = []
	if env['COMMON_LIB'] == 'bin':
		bin_linkflags += [ '-Wl,--export-all-symbols', '-Wl,--out-implib=build/' + implib ]
		bin_targets += [ implib ]
	else:
		bin_linkflags += [ '-Wl,--export-dynamic' ]

instbin = env.Program(bin_targets, src, LINKFLAGS = bin_linkflags, LIBS= [ env['LIBS'], common_lib, env['LIBDL'] ])
env.Depends("#build/configfile.o", configparser)
env.Depends("configfile.c", configparser)

spawn_fcgi = env.Program("spawn-fcgi", "spawn-fcgi.c")

if env['COMMON_LIB'] == 'bin':
	common_lib = instbin[1]

env['SHLIBPREFIX'] = ''
instlib = []
for module in modules.keys():
	libs = [ common_lib ]
	if modules[module].has_key('lib'):
		libs +=  modules[module]['lib']
	instlib += env.SharedLibrary(module, modules[module]['src'], LIBS= [ libs ])

inst = []

Default(spawn_fcgi)
inst += env.Install('${bindir}', spawn_fcgi)

if env['build_dynamic']:
	Default(instbin[0], instlib)
	inst += env.Install('${sbindir}', instbin[0])
	inst += env.Install('${libdir}', instlib)
	if env['COMMON_LIB'] == 'lib':
		Default(common_lib)
		inst += env.Install('${bindir}', common_lib)

if env['build_static']:
	Default(staticbin)
	inst += env.Install('${sbindir}', staticbin)

if env['build_fullstatic']:
	Default(fullstaticbin)
	inst += env.Install('${sbindir}', fullstaticbin)

env.Alias('dynamic', instbin)
# default all to be installed
env.Alias('install', inst)

pkgdir = '.'
tarname = env['package'] + '-' + env['version']

